<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Граф аниме</title>
    <script src="scripts/vis-network.min.js"></script>
    <style>
        html {
            background-color: transparent;
            overflow: hidden;
        }

        body {
            background: radial-gradient(at 40% 80%,rgb(22, 22, 22), rgb(60, 60, 90),rgb(22, 22, 22));
            color: #ffffff;
            font-family: Arial, sans-serif;
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow: hidden;
            height: 100vh;
        }

        #starfield {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 0;
            background: transparent;
        }

        #mynetwork {
            position: fixed;
            top: 0;
            bottom: 0;
            left: 0;
            right: 0;
            background-color: transparent;
            z-index: 1;
            /* border: 1px solid #444; */
        }

        h1 {
            font-size: 24px;
            margin: 20px 0;
            z-index: 2;
            position: relative;
        }

        #loading {
            font-size: 18px;
            margin: 20px;
            z-index: 2;
            position: relative;
        }

        #error {
            font-size: 18px;
            color: #ff5555;
            margin: 20px;
            z-index: 2;
            position: relative;
        }
    </style>
</head>

<body>
    <canvas id="starfield"></canvas>

    <div id="loading">Загрузка данных...</div>
    <div id="error" style="display: none;"></div>
    <div id="mynetwork" style="display: none;"></div>

    <script>
        // ========== Звёздное поле с параллаксом ==========

        class Star {
            constructor(x, y, size, speedFactor) {
                this.x = x;
                this.y = y;
                this.size = size;
                this.speedFactor = speedFactor;
            }

            draw(ctx) {
                ctx.beginPath();
                ctx.fillStyle = 'white';
                ctx.shadowColor = '#fff';
                ctx.shadowBlur = this.size * 1.5;
                ctx.arc(this.x, this.y, this.size, 0, 2 * Math.PI);
                ctx.fill();
            }
        }

        class Starfield {
            constructor(canvas, starCount = 150) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.starCount = starCount;
                this.stars = [];
                this.width = window.innerWidth;
                this.height = window.innerHeight;
                this.cameraX = 0;
                this.cameraY = 0;
                this.lastCameraX = 0;
                this.lastCameraY = 0;

                this.init();
                window.addEventListener('resize', () => this.resize());
            }

            init() {
                this.resize();
                this.stars = [];
                for (let i = 0; i < this.starCount; i++) {
                    const x = Math.random() * this.width;
                    const y = Math.random() * this.height;
                    const size = Math.random() * 1.3 + 0.5;
                    // speedFactor для параллакса: чем меньше, тем дальше (медленнее двигаются)
                    const speedFactor = Math.random() * 0.025 + 0.005;
                    this.stars.push(new Star(x, y, size, speedFactor));
                }
                this.draw();
            }

            resize() {
                this.width = window.innerWidth;
                this.height = window.innerHeight;
                this.canvas.width = this.width * devicePixelRatio;
                this.canvas.height = this.height * devicePixelRatio;
                this.canvas.style.width = this.width + 'px';
                this.canvas.style.height = this.height + 'px';
                this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                this.ctx.scale(devicePixelRatio, devicePixelRatio);
            }

            update(cameraX, cameraY) {
                // Обновляем смещение камеры
                this.cameraX = cameraX;
                this.cameraY = cameraY;
                this.draw();
            }

            draw() {
                const ctx = this.ctx;
                ctx.clearRect(0, 0, this.width, this.height);

                for (const star of this.stars) {
                    // Параллакс: смещаем звёзды в обратную сторону движения камеры,
                    // умножая на speedFactor, чтобы разные звёзды двигались с разной скоростью
                    let px = star.x - this.cameraX * star.speedFactor;
                    let py = star.y - this.cameraY * star.speedFactor;

                    // Чтобы звёзды не исчезали за краями, делаем "зацикливание"
                    px = ((px % this.width) + this.width) % this.width;
                    py = ((py % this.height) + this.height) % this.height;

                    star.x = px; // обновим позицию для плавности, но аккуратно - нужно чтобы не "дрожали"
                    star.y = py;
                    star.draw(ctx);
                }
            }
        }

        // ========== Граф и логика ==========

        var url_get = new URL(window.location.href);
        const MyServerURL = url_get.searchParams.get('MyServerURL') ? url_get.searchParams.get('MyServerURL') : 'server.dygdyg.ru';
        const color_link = {
            prequel: '#FFEB3B',
            sequel: '#008080',
            side_story: '#ea4c89',
            parent_story: '#ea4c89',
            other: '#000000',
            summary: '#673AB7',
        };

        // Функция для получения данных из API
        async function fetchFranchiseData() {
            try {
                const response = await fetch(`https://shikimori.one/api/animes/${url_get.searchParams.get('shikimori_id') ? url_get.searchParams.get('shikimori_id') : '29803'}/franchise`);
                if (!response.ok) {
                    throw new Error(`Ошибка HTTP: ${response.status}`);
                }
                const data = await response.json();
                return data;
            } catch (error) {
                document.getElementById('loading').style.display = 'none';
                document.getElementById('error').textContent = `Ошибка загрузки данных: ${error.message}`;
                document.getElementById('error').style.display = 'block';
                throw error;
            }
        }

        // Глобальные переменные для параллакса
        let starfield;
        let network;

        // Функция для обработки данных и создания графа
        async function createGraph() {
            const franchiseData = await fetchFranchiseData();

            // Формирование узлов с обложками
            const nodes = franchiseData.nodes.map(node => ({
                id: node.id,
                label: `[${node.kind}]\n${node.name}\n${node.year || 'Неизвестный год'}`,
                url: node.url,
                image: `//${MyServerURL}/cover2.php?id=${node.id}&url=${node.image_url}`,
                shape: 'image',
                size: 50,
                weight: 30 // Устанавливаем вес узлов
            }));

            // Формирование всех рёбер с цветами и стилем в зависимости от типа связи
            const edges = franchiseData.links
                .filter(link => link.relation !== 'prequel')
                .filter(link => link.relation !== 'other')
                //.filter(link => link.relation !== 'parent_story')
                .map(link => ({
                    id: link.id,
                    from: link.source_id,
                    to: link.target_id,
                    arrows: 'to',
                    color: {
                        color: color_link[link.relation] ? color_link[link.relation] : '#888888',
                        highlight: link.relation === 'prequel' ? '#00ff00' : link.relation === 'sequel' ? '#ff6666' : '#aaaaaa'
                    },
                    dashes: link.relation != 'prequel' && link.relation != 'sequel'
                }));

            // Создание узлов и рёбер для vis.js
            const nodesDataSet = new vis.DataSet(nodes);
            const edgesDataSet = new vis.DataSet(edges);

            // Контейнер для графа
            const container = document.getElementById('mynetwork');

            // Данные графа
            const data = {
                nodes: nodesDataSet,
                edges: edgesDataSet
            };

            // Настройки графа
            const options = {
                nodes: {
                    shape: 'image',
                    font: {
                        color: '#ffffff',
                        size: 14,
                        face: 'arial',
                        align: 'center',
                        strokeWidth: 2,
                        strokeColor: '#000000'
                    },
                    borderWidth: 2,
                    color: {
                        border: '#555',
                        highlight: {
                            border: '#777'
                        }
                    },
                    shapeProperties: {
                        useBorderWithImage: true
                    }
                },
                edges: {
                    arrows: {
                        to: { enabled: true, scaleFactor: 1 }
                    },
                    font: {
                        color: '#ffffff',
                        size: 15,
                        face: 'arial',
                        strokeWidth: 0
                    }
                },
                physics: {
                    enabled: true,
                    barnesHut: {
                        gravitationalConstant: -3000,
                        centralGravity: 0.2,
                        springLength: 600,
                        avoidOverlap: 1
                    },
                    repulsion: {
                        nodeDistance: 200
                    }
                }
            };

            // Инициализация графа
            document.getElementById('loading').style.display = 'none';
            document.getElementById('mynetwork').style.display = '';

            network = new vis.Network(container, data, options);

            // Инициализация звёздного поля
            const starfieldCanvas = document.getElementById('starfield');
            starfield = new Starfield(starfieldCanvas);

            // Обработка движения камеры (смены позиции) для параллакса
            network.on("afterDrawing", () => {
                if (!network) return;
                const viewPosition = network.getViewPosition();
                starfield.update(viewPosition.x, viewPosition.y);
            });

            // Обработка клика по узлу
            network.on("click", function (params) {
                if (params.nodes.length > 0) {
                    const nodeId = params.nodes[0];
                    const node = nodes.find(n => n.id === nodeId);
                    if (node && node.url) {
                        window.open(`index.htm?shikimori_id=${node.id}`, '_blank');
                        return;
                        if (params.event.srcEvent.shiftKey) {
                        }
                        window.location.href = `index.htm?shikimori_id=${node.id}`;
                    }
                }
            });
        }

        // Запуск создания графа
        createGraph().catch(error => console.error(error));
    </script>
</body>

</html>
