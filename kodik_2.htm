<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <title>Anime Player</title>
</head>

<body>
    <div id="control_butons">
        <div id="resume_butons">
            <div class="_button" id="resume_buton" title="Воспроизведёт следующую серию после последней просмотренной">
                Продолжить +1</div>
        </div>
        <div id="scroll_butons" class="hidden">
            <div class="_button" id="-90" title="Перемотает назад на примерную длину опенинга">
                -90с </div>
            <div class="_button" id="+90" title="Перемотает вперёд на примерную длину опенинга">90с</div>
        </div>
        <div id="panel_info_control">
            <h2>Управление</h2>
            <div class="controls-grid">
                <span class="key">Space</span><span class="desc">Плей-пауза</span>
                <span class="key">←</span><span class="desc">Перемотка назад на 10 сек</span>
                <span class="key">→</span><span class="desc">Перемотка вперёд на 10 сек</span>
                <span class="key">↑</span><span class="desc">Увеличить громкость</span>
                <span class="key">↓</span><span class="desc">Уменьшить громкость</span>
                <span class="key">A</span><span class="desc">Перемотка назад на 90 сек</span>
                <span class="key">D</span><span class="desc">Перемотка вперёд на 90 сек</span>
            </div>
        </div>
    </div>

    <iframe id="kodik" src="loading.htm" frameborder="no" allow="autoplay *; fullscreen *"></iframe>
</body>

<style>
    body {
        background-color: rgb(32, 32, 32);
        margin: 0;
    }

    .hidden {
        display: none !important;
    }

    #kodik {
        position: fixed;
        width: 100%;
        height: 100%;
        border: none;
        margin: 0;
        padding: 0;
        overflow: hidden;
        aspect-ratio: 16/9;
    }

    #control_butons {
        position: fixed;
        left: 0;
        right: 0;
        z-index: 1000;
        pointer-events: none;
        display: flex;
        align-items: center;
        flex-direction: column;
    }

    #scroll_butons {
        display: flex;
    }

    ._button {
        color: aliceblue;
        background-color: #2b3035;
        border-bottom-right-radius: 3px;
        border-bottom-left-radius: 3px;
        padding: 1ch;
        cursor: pointer;
        font: 700 12px / 30px Arial;
        pointer-events: auto;
    }

    ._button:hover {
        background-color: #363d43;
    }

    #panel_info_control {
        color: aliceblue;
        background-color: #2b3035;
        border-radius: 3px;
        padding: 1ch;
        font: 700 12px / 30px Arial;
        margin: 3px;
    }

    #panel_info_control h2 {
        color: #00b7ff;
        font-size: 1.2em;
        margin: 0;
        text-align: center;
        text-transform: uppercase;
    }

    .controls-grid {
        display: grid;
        grid-template-columns: 50px 1fr;
        align-items: center;
    }

    .controls-grid .key {
        color: #ffcc00;
        text-align: center;
        font-weight: 700;
    }

    .controls-grid .desc {
        color: aliceblue;
        font-weight: 400;
    }
</style>

<script>
    ////////////////////////////////////////////////////////////////
    // AnimeProgress module
    ////////////////////////////////////////////////////////////////

    /**
     * Модуль для сохранения и получения прогресса просмотра аниме.
     * Хранит: сезон, серию, позицию (time), material_data, lasttime.
     */
    const AnimeProgress = {
        /**
         * Сохраняет прогресс по конкретному аниме.
         * @param {number|string} shikimori_id - ID аниме.
         * @param {Object} value - Объект прогресса { season, episode }.
         * @param {Object} data_anime - Данные аниме (material_data).
         * @param {number} time - Позиция внутри серии (секунды).
         */
        save(shikimori_id, value, data_anime, time = 0) {
            let BaseAnimeCurrent = JSON.parse(localStorage.getItem("BaseAnimeCurrent")) || {};
            if (Array.isArray(BaseAnimeCurrent)) BaseAnimeCurrent = {};

            if (data_anime.material_data.episodes_total == value.episode) {
                delete BaseAnimeCurrent[shikimori_id];
            } else {
                BaseAnimeCurrent[shikimori_id] = {
                    ...value,
                    material_data: data_anime.material_data,
                    time,
                    lasttime: Date.now() / 1000
                };
            }

            BaseAnimeCurrent["lasttime"] = Date.now() / 1000;
            localStorage.setItem("BaseAnimeCurrent", JSON.stringify(BaseAnimeCurrent));
        },

        /**
         * Получает прогресс по одному тайтлу.
         * @param {number|string} shikimori_id - ID аниме.
         * @returns {Object|null} { season, episode, time, material_data, lasttime }
         */
        get(shikimori_id) {
            let BaseAnimeCurrent = JSON.parse(localStorage.getItem("BaseAnimeCurrent")) || {};
            if (Array.isArray(BaseAnimeCurrent)) BaseAnimeCurrent = {};
            return BaseAnimeCurrent[shikimori_id] || null;
        },

        /**
         * Возвращает список всех тайтлов с прогрессом.
         * Отсортирован по lasttime: новые первыми.
         */
        getAll() {
            let BaseAnimeCurrent = JSON.parse(localStorage.getItem("BaseAnimeCurrent")) || {};
            if (Array.isArray(BaseAnimeCurrent)) BaseAnimeCurrent = {};

            const result = [];
            for (const key in BaseAnimeCurrent) {
                if (key !== "lasttime") {
                    result.push({
                        shikimori_id: key,
                        ...BaseAnimeCurrent[key]
                    });
                }
            }
            result.sort((a, b) => b.lasttime - a.lasttime);
            return result;
        },

        /**
         * Полностью очищает всю историю.
         */
        clear() {
            localStorage.removeItem("BaseAnimeCurrent");
        }
    };


    ////////////////////////////////////////////////////////////////
    // Основная логика плеера
    ////////////////////////////////////////////////////////////////

    const url_get = new URL(window.location.href);
    const MyServerURL = url_get.searchParams.get('MyServerURL') || 'server.dygdyg.ru';
    const time_op = 88;
    let data_anime;
    let kodikIframe;
    let shikimori_id = url_get.searchParams.get('shikimori_id') || 50346;
    let start_load = false;

    start();

    async function start() {
        await anim_data();
        await start_kodik();
        await media_player();
    }

    async function anim_data() {
        let url_serch = `https://${MyServerURL}/kodik.php?method=search&limit=1&with_material_data=true&shikimori_id=${shikimori_id}`;
        const progress = AnimeProgress.get(shikimori_id);
        if (progress) {
            url_serch = `${url_serch}&translation_id=${progress.translation?.id || ""}`;
        }
        const response = await fetch(url_serch);
        const data = await response.json();
        data_anime = data.results[0];
    }

    async function start_kodik() {
        const progress = AnimeProgress.get(shikimori_id);

        const get_sav_url_data = progress
            ? `&season=${progress.season}&episode=${progress.episode}`
            : "&season=1&episode=1";

        const url = data_anime.link || "https://kodik.cc/find-player";
        document.getElementById("kodik").src = `${url}?shikimoriID=${shikimori_id}${get_sav_url_data}`;

        if (window.addEventListener) {
            window.addEventListener('message', kodikMessageListener);
        } else {
            window.attachEvent('onmessage', kodikMessageListener);
        }

        kodikIframe = document.getElementById("kodik").contentWindow;

        document.getElementById("kodik").addEventListener('load', () => {
            if (!start_load && progress) {
                kodik_player_api({
                    method: "change_episode",
                    season: progress.season,
                    episode: progress.episode
                });
                if (progress.time > 5) {
                    setTimeout(() => {
                        kodik_player_api({ method: "seek", seconds: progress.time });
                    }, 2000);
                }
                start_load = true;
            }
        });

        document.getElementById("resume_buton").addEventListener('click', () => {
            if (progress) {
                kodik_player_api({
                    method: "change_episode",
                    season: progress.season,
                    episode: progress.episode + 1
                });
            }
            document.getElementById("resume_buton").classList.add("hidden");
            setTimeout(() => kodik_player_api({ method: "play" }), 1500);
        });
    }

    function kodikMessageListener(message) {
        switch (message.data.key) {
            case "kodik_player_volume_change":
                navigator.mediaSession.metadata.volume = message.data.value.volume;
                break;

            case "kodik_player_play":
                navigator.mediaSession.metadata.isPlay = true;
                document.getElementById("resume_buton").classList.add("hidden");
                document.getElementById("panel_info_control").classList.add("hidden");
                break;

            case "kodik_player_pause":
                navigator.mediaSession.metadata.isPlay = false;
                break;

            case "kodik_player_time_update":
                navigator.mediaSession.metadata.time = message.data.value;
                const prog = AnimeProgress.get(shikimori_id);
                if (prog) {
                    AnimeProgress.save(shikimori_id, prog, data_anime, message.data.value);
                }
                break;

            case "kodik_player_current_episode":
                navigator.mediaSession.metadata.time = 0;
                navigator.mediaSession.metadata.artist = `Серия: ${message.data.value.episode}`;
                AnimeProgress.save(shikimori_id, message.data.value, data_anime, 0);
                break;
        }
    }

    function kodik_player_api(e) {
        kodikIframe.postMessage({ key: "kodik_player_api", value: e }, '*');
    }

    async function media_player() {
        if ('mediaSession' in navigator) {
            navigator.mediaSession.metadata = new MediaMetadata({
                title: data_anime.material_data.title,
                artist: ``,
                album: '',
                artwork: [{ src: data_anime.material_data.poster_url }]
            });

            navigator.mediaSession.metadata.time = 0;
            navigator.mediaSession.metadata.volume = 1;
            navigator.mediaSession.metadata.isPlay = false;
        }
    }
</script>

</html>